/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function e(e){return"[object Object]"===Object.prototype.toString.call(e)}function t(){return t=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},t.apply(this,arguments)}function n(e,t){if(null==e)return{};var n,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)t.indexOf(n=o[r])>=0||(i[n]=e[n]);return i}const r={silent:!1,logLevel:"warn"},i=["validator"],o=Object.prototype,a=o.toString,s=o.hasOwnProperty,u=/^\s*function (\w+)/;function l(e){var t;const n=null!==(t=null==e?void 0:e.type)&&void 0!==t?t:e;if(n){const e=n.toString().match(u);return e?e[1]:""}return""}const c=function(t){var n,r;return!1!==e(t)&&(void 0===(n=t.constructor)||!1!==e(r=n.prototype)&&!1!==r.hasOwnProperty("isPrototypeOf"))};let d=e=>e;const f=(e,t)=>s.call(e,t),p=Number.isInteger||function(e){return"number"==typeof e&&isFinite(e)&&Math.floor(e)===e},y=Array.isArray||function(e){return"[object Array]"===a.call(e)},v=e=>"[object Function]"===a.call(e),h=(e,t)=>c(e)&&f(e,"_vueTypes_name")&&(!t||e._vueTypes_name===t),b=e=>c(e)&&(f(e,"type")||["_vueTypes_name","validator","default","required"].some((t=>f(e,t))));function g(e,t){return Object.defineProperty(e.bind(t),"__original",{value:e})}function O(e,t,n=!1){let r,i=!0,o="";r=c(e)?e:{type:e};const a=h(r)?r._vueTypes_name+" - ":"";if(b(r)&&null!==r.type){if(void 0===r.type||!0===r.type)return i;if(!r.required&&void 0===t)return i;y(r.type)?(i=r.type.some((e=>!0===O(e,t,!0))),o=r.type.map((e=>l(e))).join(" or ")):(o=l(r),i="Array"===o?y(t):"Object"===o?c(t):"String"===o||"Number"===o||"Boolean"===o||"Function"===o?function(e){if(null==e)return"";const t=e.constructor.toString().match(u);return t?t[1]:""}(t)===o:t instanceof r.type)}if(!i){const e=`${a}value "${t}" should be of type "${o}"`;return!1===n?(d(e),!1):e}if(f(r,"validator")&&v(r.validator)){const e=d,o=[];if(d=e=>{o.push(e)},i=r.validator(t),d=e,!i){const e=(o.length>1?"* ":"")+o.join("\n* ");return o.length=0,!1===n?(d(e),i):e}}return i}function m(e,t){const n=Object.defineProperties(t,{_vueTypes_name:{value:e,writable:!0},isRequired:{get(){return this.required=!0,this}},def:{value(e){return void 0===e?this.type===Boolean||Array.isArray(this.type)&&this.type.includes(Boolean)?void(this.default=void 0):(f(this,"default")&&delete this.default,this):v(e)||!0===O(this,e,!0)?(this.default=y(e)?()=>[...e]:c(e)?()=>Object.assign({},e):e,this):(d(`${this._vueTypes_name} - invalid default value: "${e}"`),this)}}}),{validator:r}=n;return v(r)&&(n.validator=g(r,n)),n}function j(e,t){const n=m(e,t);return Object.defineProperty(n,"validate",{value(e){return v(this.validator)&&d(`${this._vueTypes_name} - calling .validate() will overwrite the current custom validator function. Validator info:\n${JSON.stringify(this)}`),this.validator=g(e,this),this}})}function _(e,t,r){const o=function(e){const t={};return Object.getOwnPropertyNames(e).forEach((n=>{t[n]=Object.getOwnPropertyDescriptor(e,n)})),Object.defineProperties({},t)}(t);if(o._vueTypes_name=e,!c(r))return o;const{validator:a}=r,s=n(r,i);if(v(a)){let{validator:e}=o;e&&(e=null!==(l=(u=e).__original)&&void 0!==l?l:u),o.validator=g(e?function(t){return e.call(this,t)&&a.call(this,t)}:a,o)}var u,l;return Object.assign(o,s)}function T(e){return e.replace(/^(?!\s*$)/gm,"  ")}const $=()=>j("boolean",{type:Boolean});function w(e,t="custom validation failed"){if("function"!=typeof e)throw new TypeError("[VueTypes error]: You must provide a function as argument");return m(e.name||"<<anonymous function>>",{type:null,validator(n){const r=e(n);return r||d(`${this._vueTypes_name} - ${t}`),r}})}function x(e){if(!y(e))throw new TypeError("[VueTypes error]: You must provide an array as argument.");const t=`oneOf - value should be one of "${e.map((e=>"symbol"==typeof e?e.toString():e)).join('", "')}".`,n={validator(n){const r=-1!==e.indexOf(n);return r||d(t),r}};if(-1===e.indexOf(null)){const t=e.reduce(((e,t)=>{if(null!=t){const n=t.constructor;-1===e.indexOf(n)&&e.push(n)}return e}),[]);t.length>0&&(n.type=t)}return m("oneOf",n)}function P(e){if(!y(e))throw new TypeError("[VueTypes error]: You must provide an array as argument");let t=!1,n=!1,r=[];for(let o=0;o<e.length;o+=1){const i=e[o];if(b(i)){if(v(i.validator)&&(t=!0),h(i,"oneOf")&&i.type){r=r.concat(i.type);continue}if(h(i,"nullable")){n=!0;continue}if(!0===i.type||!i.type){d('oneOfType - invalid usage of "true" and "null" as types.');continue}r=r.concat(i.type)}else r.push(i)}r=r.filter(((e,t)=>r.indexOf(e)===t));const i=!1===n&&r.length>0?r:null;return m("oneOfType",t?{type:i,validator(t){const n=[],r=e.some((e=>{const r=O(e,t,!0);return"string"==typeof r&&n.push(r),!0===r}));return r||d(`oneOfType - provided value does not match any of the ${n.length} passed-in validators:\n${T(n.join("\n"))}`),r}}:{type:i})}function S(e){return m("arrayOf",{type:Array,validator(t){let n="";const r=t.every((t=>(n=O(e,t,!0),!0===n)));return r||d(`arrayOf - value validation error:\n${T(n)}`),r}})}function A(e){return m("instanceOf",{type:e})}function q(e){return m("objectOf",{type:Object,validator(t){let n="";const r=Object.keys(t).every((r=>(n=O(e,t[r],!0),!0===n)));return r||d(`objectOf - value validation error:\n${T(n)}`),r}})}function E(e){const t=Object.keys(e),n=t.filter((t=>{var n;return!(null===(n=e[t])||void 0===n||!n.required)})),r=m("shape",{type:Object,validator(r){if(!c(r))return!1;const i=Object.keys(r);if(n.length>0&&n.some((e=>-1===i.indexOf(e)))){const e=n.filter((e=>-1===i.indexOf(e)));return d(1===e.length?`shape - required property "${e[0]}" is not defined.`:`shape - required properties "${e.join('", "')}" are not defined.`),!1}return i.every((n=>{if(-1===t.indexOf(n))return!0===this._vueTypes_isLoose||(d(`shape - shape definition does not include a "${n}" property. Allowed keys: "${t.join('", "')}".`),!1);const i=O(e[n],r[n],!0);return"string"==typeof i&&d(`shape - "${n}" property validation error:\n ${T(i)}`),!0===i}))}});return Object.defineProperty(r,"_vueTypes_isLoose",{writable:!0,value:!1}),Object.defineProperty(r,"loose",{get(){return this._vueTypes_isLoose=!0,this}}),r}const k=["name","validate","getter"],N=(()=>{var e;return(e=class{static get any(){return j("any",{})}static get func(){return j("function",{type:Function}).def(this.defaults.func)}static get bool(){return void 0===this.defaults.bool?$():$().def(this.defaults.bool)}static get string(){return j("string",{type:String}).def(this.defaults.string)}static get number(){return j("number",{type:Number}).def(this.defaults.number)}static get array(){return j("array",{type:Array}).def(this.defaults.array)}static get object(){return j("object",{type:Object}).def(this.defaults.object)}static get integer(){return m("integer",{type:Number,validator(e){const t=p(e);return!1===t&&d(`integer - "${e}" is not an integer`),t}}).def(this.defaults.integer)}static get symbol(){return m("symbol",{validator(e){const t="symbol"==typeof e;return!1===t&&d(`symbol - invalid value "${e}"`),t}})}static get nullable(){return Object.defineProperty({type:null,validator(e){const t=null===e;return!1===t&&d("nullable - value should be null"),t}},"_vueTypes_name",{value:"nullable"})}static extend(e){if(d("VueTypes.extend is deprecated. Use the ES6+ method instead. See https://dwightjack.github.io/vue-types/advanced/extending-vue-types.html#extending-namespaced-validators-in-es6 for details."),y(e))return e.forEach((e=>this.extend(e))),this;const{name:t,validate:r=!1,getter:i=!1}=e,o=n(e,k);if(f(this,t))throw new TypeError(`[VueTypes error]: Type "${t}" already defined`);const{type:a}=o;if(h(a))return delete o.type,Object.defineProperty(this,t,i?{get:()=>_(t,a,o)}:{value(...e){const n=_(t,a,o);return n.validator&&(n.validator=n.validator.bind(n,...e)),n}});let s;return s=i?{get(){const e=Object.assign({},o);return r?j(t,e):m(t,e)},enumerable:!0}:{value(...e){const n=Object.assign({},o);let i;return i=r?j(t,n):m(t,n),n.validator&&(i.validator=n.validator.bind(i,...e)),i},enumerable:!0},Object.defineProperty(this,t,s)}}).defaults={},e.sensibleDefaults=void 0,e.config=r,e.custom=w,e.oneOf=x,e.instanceOf=A,e.oneOfType=P,e.arrayOf=S,e.objectOf=q,e.shape=E,e.utils={validate:(e,t)=>!0===O(t,e,!0),toType:(e,t,n=!1)=>n?j(e,t):m(e,t)},e})();function V(e={func:()=>{},bool:!0,string:"",number:0,array:()=>[],object:()=>({}),integer:0}){var n;return(n=class extends N{static get sensibleDefaults(){return t({},this.defaults)}static set sensibleDefaults(n){this.defaults=!1!==n?t({},!0!==n?n:e):{}}}).defaults=t({},e),n}class B extends(V()){}const D=V({func:void 0,bool:void 0,string:void 0,number:void 0,object:void 0,integer:void 0});export{D as p};
